---
layout: post
title: "JavaScript学习笔记 "
subtitle: '记录阮一峰老师的《JavaScript 语言入门教程》中的一些需要注意的地方'
date: 2021-02-16 20:00:00
author: "突击核"
header-style: text
hidden: false
tags:
  - JavaScript
---

# JavaScript学习笔记   
记录阮一峰老师的[《JavaScript 语言入门教程》](https://wangdoc.com/javascript/)中的一些需要注意的地方
## 入门篇   
- 如果只是声明变量而没有赋值，则该变量的值是`undefined`。`undefined`是一个特殊的值，表示“无定义”。
- 如果变量赋值的时候，忘了写var命令，这条语句也是有效的
- 如果一个变量没有声明就直接使用，JavaScript 会报错，告诉你变量未定义
- JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，**就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）**。
- JavaScript中标识符第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_），不可以为数字
- 注释除了单行注释`//`和多行注释`/*和*/`；还兼容`<!--`和`-->`作为单行注释；`-->`只有在行首，才会被当成单行注释，否则会当作正常的运算。
- `if`后面的表达式之中，不要混淆赋值表达式`=`、严格相等运算符`===`和相等运算符`==`；switch语句后面的表达式，与case语句后面的表示式比较运行结果时，采用的是严格相等运算符`===`，而不是相等运算符`==`，这意味着比较时不会发生类型转换。
- `do...while`循环`while`语句后面的分号注意不要省略
- `break`语句用于跳出代码块或循环;`continue`语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。
- JavaScript 语言允许，语句的前面有标签（`label`），相当于定位符，用于跳转到程序的任意位置


## 数据类型   
- 函数其实是处理数据的方法，JavaScript 把它当成一种数据类型，可以赋值给变量，这为编程带来了很大的灵活性，也为 JavaScript 的“函数式编程”奠定了基础。
- `typeof`运算符可以返回一个值的数据类型。数值、字符串、布尔值分别返回`number`、`string`、`boolean`。函数返回`function`、`undefined`返回`undefined`。利用这一点，`typeof`可以用来检查一个没有声明的变量，`if (typeof v === "undefined") {}`。对象返回`object`；在 JavaScript 内部，数组本质上只是一种特殊的对象。这里顺便提一下，`instanceof`运算符可以区分数组和对象。`null`返回`object`（`null`的类型是`object`，这是由于历史原因造成的）。
- `null`表示空值，即该处的值现在为空，`null`转为数字时，自动变成`0`。`undefined`表示“未定义”，转为数值时为`NaN`。
- 如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为`false`，其他值都视为`true`（如空数组`[]`和空对象`{}`）：`undefined`、`null`、`false`、`0`、`NaN`、`""或''（空字符串）`
- JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数。某些运算只有整数才能完成，此时 JavaScript 会自动把64位浮点数，转成32位整数；由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心

```javascript
0.1 + 0.2 === 0.3
// false
0.3 / 0.1
// 2.9999999999999996
(0.3 - 0.2) === (0.2 - 0.1)
// false
```
- 根据国际标准 IEEE 754，JavaScript 浮点数的64个二进制位，从最左边开始，是这样组成的。 第1位：符号位，0表示正数，1表示负数 第2位到第12位（共11位）：指数部分 第13位到第64位（共52位）：小数部分（即有效数字）。如果指数部分的值在0到2047之间（不含两个端点），那么有效数字的第一位默认总是1，不保存在64位浮点数之中。也就是说，有效数字这时总是1.xx...xx的形式，其中xx..xx的部分保存在64位浮点数之中，最长可能为52位。
- JavaScript 提供的有效数字最长为53个二进制位。即$2^{-53}$到$2^{-53}$，都可以精确表示。由于2的53次方是一个16位的十进制数值，所以简单的法则就是，JavaScript 对15位的十进制数都可以精确处理。大于2的53次方以后，多出来的有效数字都会无法保存，变成0。
- JavaScript 能够表示的数值范围为$2^{1024}$到$2^{-1023}$（开区间），超出这个范围的数无法表示。如果一个数大于等于2的1024次方，那么就会发生“正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回`Infinity`。如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“负向溢出”，即 JavaScript 无法表示这么小的数，这时会直接返回0。
- JavaScript 提供Number对象的`MAX_VALUE`(1.7976931348623157e+308)和M`IN_VALUE`(5e-324)属性，返回可以表示的具体的最大值和最小值。
- 以下两种情况，JavaScript 会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示:小数点前的数字多于21位、小数点后的零多于5个
- 默认情况下，JavaScript 内部会自动将八进制、十六进制、二进制转为十进制。通常来说，有前导0的数值会被视为八进制，但是如果前导0后面有数字8和9，则该数值被视为十进制。前导0表示八进制，处理时很容易造成混乱。ES5 的严格模式和 ES6，已经废除了这种表示法，但是浏览器为了兼容以前的代码，目前还继续支持这种表示法。
- JavaScript 内部实际上存在2个`0`：一个是`+0`，一个是`-0`，区别就是64位浮点数表示法的符号位不同。它们是等价的。几乎所有场合，正零和负零都会被当作正常的`0`。唯一有区别的场合是，`+0`或`-0`当作分母，返回的值是不相等的。因为除以正零得到`+Infinity`，除以负零得到`-Infinity`，这两者是不相等的。
- `NaN`是 JavaScript 的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合。NaN不等于任何值，包括它本身。`NaN === NaN // false`。`NaN`与任何数（包括它自己）的运算，得到的都是`NaN`。
- `Infinity`表示“无穷”，用来表示两种场景。一种是一个正的数值太大，或一个负的数值太小，无法表示；另一种是非0数值除以0，得到`Infinity`。`Infinity`大于一切数值（除了`NaN`），`-Infinity`小于一切数值（除了`NaN`）。`Infinity`与`NaN`比较，总是返回false。
- `Infinity`的四则运算，符合无穷的数学计算规则。`Infinity`与`undefined`计算，返回的都是NaN。
- `parseInt`方法用于将字符串转为整数。如果字符串头部有空格，空格会被自动去除。如果`parseInt`的参数不是字符串，则会先转为字符串再转换。字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回`NaN`。
